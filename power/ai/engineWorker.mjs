let DEBUG=!1,INFO=!0,WARNING=!0,ERROR=!0,DISABLE_LOGGING=!1;const enableDebug=()=>{DEBUG=!0},disableDebug=()=>{DEBUG=!1},disableInfo=()=>{INFO=!1,DEBUG=!1},disableWarning=()=>{WARNING=!1,disableInfo()},disableError=()=>{ERROR=!1,disableWarning()},disableLogging=()=>{DISABLE_LOGGING=!0},enableLogging=()=>{DISABLE_LOGGING=!1},log=(...e)=>!DISABLE_LOGGING&&console&&console.log(...e),debug=(...e)=>DEBUG&&log("DEBUG: ",...e),info=(...e)=>INFO&&log("INFO: ",...e),warn=(...e)=>WARNING&&log("WARN: ",...e),error=(...e)=>ERROR&&log("ERROR: ",...e),isNotNullOrUndefined=e=>null!=e,isNullOrUndefined=e=>!isNotNullOrUndefined(e);var utils={disableInfo:disableInfo,disableWarning:disableWarning,disableError:disableError,disableLogging:disableLogging,enableLogging:enableLogging,disableDebug:disableDebug,enableDebug:enableDebug,debug:debug,info:info,warn:warn,error:error,log:log,isNullOrUndefined:isNullOrUndefined,isNotNullOrUndefined:isNotNullOrUndefined};const Winner=Object.freeze({ATTACKER:"ATTACKER",DEFENDER:"DEFENDER"}),MoveType=Object.freeze({MOVE:"MOVE",ATTACK:"ATTACK",INVALID:"INVALID",SACRIFICE:"SACRIFICE",PROMOTION:"PROMOTION",EN_PASSANT_ATTACK:"EN_PASSANT_ATTACK",PROMOTION_ATTACK:"PROMOTION_ATTACK",CASTLE:"CASTLE"}),Side=Object.freeze({WHITE:"WHITE",BLACK:"BLACK"}),PieceType=Object.freeze({PAWN:"PAWN",KNIGHT:"KNIGHT",ROOK:"ROOK",KING:"KING"}),GameStatus=Object.freeze({WHITE_WON:"WHITE_WON",BLACK_WON:"BLACK_WON",IN_PROGRESS:"IN_PROGRESS"}),applyProps=(e,t)=>{e.toJson=()=>t,e.constructor.fromJson=t=>new e.constructor(t),Object.defineProperty(e,"canCastle",{get:()=>void 0!==t.canCastle&&t.canCastle}),Object.defineProperty(e,"x",{get:()=>t.position[0]}),Object.defineProperty(e,"y",{get:()=>t.position[1]}),Object.defineProperty(e,"side",{get:()=>t.side}),Object.defineProperty(e,"power",{get:()=>t.power}),Object.defineProperty(e,"type",{get:()=>t.type}),e.markMoved=()=>e,e.isBasicValidMove=(t,i,n)=>{if(i===e.x&&n===e.y)return utils.warn(`Tried to move ${e.type} into same place.`),!1;if(!t.isWithinBoundaries(i,n))return utils.warn(`Tried to move ${e.type} outside of boundaries.`),!1;if(t.containsPieceAt(i,n)){const s=t.getPieceAt(i,n);if(e.isAlly(s)&&s.type==PieceType.KING)return!1}return!0}},DEFAULT_STATE=Object.freeze({position:[0,0],power:0,side:Side.WHITE});function Knight(e=DEFAULT_STATE){const t=Object.freeze(Object.assign({type:PieceType.KNIGHT},DEFAULT_STATE,e));return applyProps(this,t),this.copy=e=>new Knight(Object.assign({},t,e)),this.isAlly=e=>this.side==e.side,this.computeMoveType=(e,t,i)=>{const n=Math.abs(t-this.x),s=Math.abs(i-this.y);if(t===this.x&&i===this.y)return utils.warn("Tried to move Knight into same place."),MoveType.INVALID;if(!e.isWithinBoundaries(t,i))return utils.warn("Tried to move Knight outside of boundaries."),MoveType.INVALID;if(n>2||s>2)return utils.warn("Tried to move Knight more than two squares away."),MoveType.INVALID;if(1==n&&2==s||1==s&&2==n)return utils.warn("L moves not allowed for Knights."),MoveType.INVALID;if(n<=1&&s<=1)return e.containsPieceAt(t,i)?(utils.warn("Knights cannot attack immediate squares."),MoveType.INVALID):MoveType.MOVE;if(0===n&&!e.containsPieceAt(t,this.y+(i-this.y)/2)||0===s&&!e.containsPieceAt(this.x+(t-this.x)/2,i)||s>1&&n>1&&!e.containsPieceAt(this.x+(t-this.x)/2,this.y+(i-this.y)/2))return utils.warn("Tried skip square with Knight without a piece in between."),MoveType.INVALID;if(e.containsPieceAt(t,i)){const n=e.getPieceAt(t,i);return this.isAlly(n)?n.type===PieceType.KING?(utils.warn("You can't sacrifice the King!"),MoveType.INVALID):MoveType.SACRIFICE:MoveType.ATTACK}return MoveType.MOVE},this}const DEFAULT_STATE$1=Object.freeze({position:[0,0],power:0,side:Side.WHITE,canCastle:!0});function Rook(e=DEFAULT_STATE$1){const t=Object.freeze(Object.assign({type:PieceType.ROOK},DEFAULT_STATE$1,e));return applyProps(this,t),this.copy=e=>new Rook(Object.assign({},t,e)),this.markMoved=()=>this.copy({canCastle:!1}),this.isAlly=e=>this.side==e.side,this.computeMoveType=(e,t,i)=>{if(!this.isBasicValidMove(e,t,i))return MoveType.INVALID;const n=Math.abs(t-this.x),s=Math.abs(i-this.y);if(n>0&&s>0)return utils.warn("Tried to move rook in a non-straight line."),MoveType.INVALID;if(n>1){const n=Math.min(this.x,t),s=Math.max(this.x,t);for(let t=n+1;t<s;t++)if(e.containsPieceAt(t,i))return utils.warn("Rooks can't skip pieces."),MoveType.INVALID}if(s>1){const n=Math.min(this.y,i),s=Math.max(this.y,i);for(let i=n+1;i<s;i++)if(e.containsPieceAt(t,i))return utils.warn("Rooks can't skip pieces."),MoveType.INVALID}if(e.containsPieceAt(t,i)){const n=e.getPieceAt(t,i);return this.isAlly(n)?MoveType.SACRIFICE:MoveType.ATTACK}return MoveType.MOVE},this}const DEFAULT_STATE$2=Object.freeze({position:[0,0],power:0,side:Side.WHITE});function Pawn(e=DEFAULT_STATE$2){const t=Object.freeze(Object.assign({type:PieceType.PAWN},DEFAULT_STATE$2,e));applyProps(this,t),this.copy=e=>new Pawn(Object.assign({},t,e)),this.isAlly=e=>this.side===e.side,this.isFoe=e=>!this.isAlly(e);const i=(e,t,i)=>{if(e.containsPieceAt(t,i)){const n=e.getPieceAt(t,i);return this.isAlly(n)?MoveType.SACRIFICE:0===i&&this.side===Side.WHITE||7===i&&this.side===Side.BLACK?MoveType.PROMOTION_ATTACK:MoveType.ATTACK}{const n=e.enPassant;if(n&&this.isFoe(n)){if(n.x==t&&(this.side==Side.WHITE&&i==n.y-1||this.side==Side.BLACK&&i==n.y+1))return MoveType.EN_PASSANT_ATTACK}return utils.warn("Cannot move in diagonal. Only attack or sacrifice."),MoveType.INVALID}},n=(e,t,i)=>{const n=Math.abs(t-this.x),s=Math.abs(i-this.y);return this.side===Side.WHITE&&i>this.y||this.side===Side.BLACK&&i<this.y?(utils.warn("Illegal move: Tried to move Pawn backwards."),!0):n>0&&0===s?(utils.warn("Illegal move: Tried to move Pawn sideways."),!0):s>2?(utils.warn("Tried to move Pawn more than two squares away."),!0):n>1?(utils.warn("Pawns cannot move more than 1 square in x-axis."),!0):1===n&&s>=2&&(utils.warn("Pawns cannot move in L patterns."),!0)},s=(e,t,i)=>{Math.abs(t-this.x);const n=Math.abs(i-this.y);return 2===n&&(this.side===Side.WHITE&&e.containsPieceAt(t,i+1)||this.side===Side.BLACK&&e.containsPieceAt(t,i-1))?(utils.warn("Pawns cannot skip pieces"),MoveType.INVALID):n>=1?e.containsPieceAt(t,i)?(utils.warn("Pawns cannot attack immediate squares."),MoveType.INVALID):this.side===Side.WHITE&&0===i||this.side===Side.BLACK&&7===i?MoveType.PROMOTION:MoveType.MOVE:(utils.warn(`Illegal pawn move from (${this.x},${this.y}) to (${t},${i}).`),MoveType.INVALID)};return this.computeMoveType=(e,t,o)=>{const r=Math.abs(t-this.x),a=Math.abs(o-this.y);return this.isBasicValidMove(e,t,o)?n(0,t,o)?MoveType.INVALID:1===r&&1===a?i(e,t,o):s(e,t,o):MoveType.INVALID},this}const DEFAULT_STATE$3=Object.freeze({position:[0,0],power:0,side:Side.WHITE,canCastle:!0});function King(e=DEFAULT_STATE$3){const t=Object.freeze(Object.assign({type:PieceType.KING},DEFAULT_STATE$3,e));return applyProps(this,t),this.copy=e=>new King(Object.assign({},t,e)),this.markMoved=()=>this.copy({canCastle:!1}),this.isAlly=e=>this.side==e.side,this.computeMoveType=(e,t,i)=>{if(!this.isBasicValidMove(e,t,i))return MoveType.INVALID;const n=Math.abs(t-this.x),s=Math.abs(i-this.y);if(this.canCastle&&0==s&&n>1){const n=Math.min(this.x,t)+1;if(e.containsPieceAt(n,i))return utils.warn("Kings cannot skip pieces."),MoveType.INVALID;const s=e.getPieceAt(t,i);if(null!=s&&s.type==PieceType.ROOK&&this.isAlly(s)&&s.canCastle)return MoveType.CASTLE}return n>1||s>1?(utils.warn("Tried to move king more than 1 square."),MoveType.INVALID):e.containsPieceAt(t,i)?this.isAlly(e.getPieceAt(t,i))?(utils.warn("Kings cannot sacrifice allies."),MoveType.INVALID):MoveType.ATTACK:MoveType.MOVE},this}const EngineOutcome={NONE:"NONE",ALWAYS_WIN:"ALWAYS_WIN",ALWAYS_LOSE:"ALWAYS_LOSE"},STARTING_BOARD=Object.freeze([[new Rook({position:[0,0],side:Side.BLACK}),new Knight({position:[1,0],side:Side.BLACK}),new King({position:[2,0],side:Side.BLACK}),new Knight({position:[3,0],side:Side.BLACK}),new Rook({position:[4,0],side:Side.BLACK})],[new Pawn({position:[0,1],side:Side.BLACK}),new Pawn({position:[1,1],side:Side.BLACK}),new Pawn({position:[2,1],side:Side.BLACK}),new Pawn({position:[3,1],side:Side.BLACK}),new Pawn({position:[4,1],side:Side.BLACK})],[null,null,null,null,null],[null,null,null,null,null],[null,null,null,null,null],[null,null,null,null,null],[new Pawn({position:[0,6],side:Side.WHITE}),new Pawn({position:[1,6],side:Side.WHITE}),new Pawn({position:[2,6],side:Side.WHITE}),new Pawn({position:[3,6],side:Side.WHITE}),new Pawn({position:[4,6],side:Side.WHITE})],[new Rook({position:[0,7],side:Side.WHITE}),new Knight({position:[1,7],side:Side.WHITE}),new King({position:[2,7],side:Side.WHITE}),new Knight({position:[3,7],side:Side.WHITE}),new Rook({position:[4,7],side:Side.WHITE})]]);function attack(e,t,i=EngineOutcome.NONE){let n=null;return n=i===EngineOutcome.ALWAYS_WIN?Winner.ATTACKER:i===EngineOutcome.ALWAYS_LOSE?Winner.DEFENDER:determineWinner(e,t,i),n===Winner.ATTACKER?{result:n,winner:e.copy({power:e.power-1,position:t.position})}:{result:n,winner:t.copy({power:t.power-1})}}function determineWinner(e,t){return realizeOdds(computePieceWinOdds(e,t))?Winner.ATTACKER:Winner.DEFENDER}function computePieceWinOdds(e,t){let i=e.power,n=t.power;return e.type===PieceType.KING&&t.type!==PieceType.KING?n=0:t.type===PieceType.KING&&e.type!==PieceType.KING&&(i=0),computeWinOdds(i,n)}function computeWinOdds(e,t){const i=1/2**(1+Math.abs(e-t));return e>=t?1-i:i}function realizeOdds(e){return Math.random()<e}function computeSacrificePower(e,t){return e<0?e>t?e:e===t?e+1:e+(t-e):t<0?e:e+t+1}function sacrifice(e,t){return e.copy({power:computeSacrificePower(e.power,t.power)})}function setPiece(e,t,i,n){return e.map((e,s)=>s===n?e.map((e,n)=>n===i?null==t?null:t.copy({position:[n,s]}).markMoved():e):e)}function removePiece(e,t,i){return setPiece(e,null,t,i)}function movePiece(e,t,i){const[n,s]=t,[o,r]=i,a=e[s][n];if(null==a)throw`There is no piece to move at (${t})!!`;const c=removePiece(e,n,s),l=a.copy({position:i}),u=setPiece(c,l,o,r);let d=null;return l.type===PieceType.PAWN&&2==Math.abs(s-r)&&(d=l),{squares:u,enPassant:d}}const DEFAULT_BOARD_STATE={squares:STARTING_BOARD,enPassant:null,promotion:null,gameStatus:GameStatus.IN_PROGRESS};function Board(e=DEFAULT_BOARD_STATE){const t=Object.freeze(Object.assign({},DEFAULT_BOARD_STATE,e));Object.defineProperty(this,"enPassant",{get:()=>t.enPassant}),Object.defineProperty(this,"pendingPromotion",{get:()=>null!==t.promotion}),Object.defineProperty(this,"gameStatus",{get:()=>t.gameStatus}),this.copy=(e=null)=>{if(null===e)return this;return new Board(Object.assign({},t,e))},this.toJson=()=>({squares:this.getRows().map(e=>e.map(e=>null===e?null:e.toJson())),enPassant:t.enPassant?t.enPassant.toJson():null,promotion:t.promotion?t.promotion.toJson():null,gameStatus:t.gameStatus});const i=(e,i)=>{const{squares:n,enPassant:s}=movePiece(t.squares,e,i);return this.copy({squares:n,enPassant:s})},n=(e,t,i)=>{let n=this.gameStatus;return e.result===Winner.ATTACKER&&i.type===PieceType.KING&&(n=e.winner.side===Side.WHITE?GameStatus.WHITE_WON:GameStatus.BLACK_WON),e.result===Winner.DEFENDER&&t.type===PieceType.KING&&(n=e.winner.side===Side.BLACK?GameStatus.BLACK_WON:GameStatus.WHITE_WON),n},s=(e,i,s=EngineOutcome)=>{const[o,r]=e,[a,c]=i,l=this.getPieceAt(o,r),u=this.getPieceAt(a,c),d=attack(l,u,s);return this.copy({squares:removePiece(setPiece(t.squares,d.winner,a,c),o,r),enPassant:null,gameStatus:n(d,l,u)})},o=(e,i)=>{const[n,s]=e,[o,r]=i,a=this.getPieceAt(n,s),c=this.getPieceAt(o,r);if(c.type===PieceType.KING)return this;const l=sacrifice(a,c);return this.copy({squares:removePiece(setPiece(t.squares,l,o,r),n,s),enPassant:null})},r=(e,i,n=EngineOutcome.NONE)=>{const[s,o]=e,[r,a]=i,c=this.getPieceAt(s,o),{result:l,winner:u}=attack(c,this.enPassant);let d=null;return d=l===Winner.ATTACKER?setPiece(removePiece(removePiece(t.squares,this.enPassant.x,this.enPassant.y),s,o),u,r,a):setPiece(removePiece(t.squares,s,o),u,this.enPassant.x,this.enPassant.y),this.copy({squares:d,enPassant:null})},a=(e,t)=>{const[n,s]=t,o=i(e,t);return o.copy({promotion:o.getPieceAt(n,s)})},c=(e,t,i=EngineOutcome.NONE)=>{const[o,r]=t,c=s(e,t,i),l=c.getPieceAt(o,r),u=this.getPieceAt(o,r);return l.type===PieceType.PAWN?a(e,t).copy({gameStatus:n({result:Winner.ATTACKER,winner:l},l,u)}):c},l=(e,i)=>{const[n]=e,[s,o]=i,{squares:r}=t,a=this.getPieceAt(s,o),c=Math.min(n,s)+1,{squares:l,enPassant:u}=movePiece(r,e,i),d=setPiece(l,a,c,o);return this.copy({squares:d,enPassant:u})};return this.makeMove=(e,t,n=EngineOutcome.NONE)=>{const[u,d]=e,[p,T]=t;if(u===p&&d===T)throw`Source (${e}) and destination (${t}) for a move can't be the same.`;const h=this.getPieceAt(u,d);if(null==h)return utils.warn(`There is no piece to move at (${e}).`),this;const A=h.computeMoveType(this,p,T);switch(A){case MoveType.INVALID:return utils.info(`Invalid move from (${e}) to (${t})`),this;case MoveType.ATTACK:return s(e,t,n);case MoveType.MOVE:return i(e,t);case MoveType.SACRIFICE:return o(e,t);case MoveType.EN_PASSANT_ATTACK:return r(e,t,n);case MoveType.PROMOTION:return a(e,t);case MoveType.PROMOTION_ATTACK:return c(e,t,n);case MoveType.CASTLE:return l(e,t);default:throw`${A} is not supported.`}},this.setPromotion=(e=PieceType.ROOK)=>{const[i,n]=[t.promotion.x,t.promotion.y],s=t.promotion.side;let o;o=e===PieceType.ROOK?new Rook({side:s,position:[i,n],power:0}):new Knight({side:s,position:[i,n],power:0});const r=setPiece(t.squares,o,i,n);return this.copy({squares:r,promotion:null})},this.getRow=e=>{if(e<0||e>t.squares.length)throw`Row indices can only be values 0-7. Got: ${e}.`;return Object.freeze(t.squares[e])},this.getRows=()=>Object.freeze(t.squares),this.getPieceAt=(e,i)=>t.squares[i][e],this.containsPieceAt=(e,t)=>null!==this.getPieceAt(e,t),this.isWithinBoundaries=(e,i)=>e>=0&&i>=0&&t.squares.length>i&&t.squares[0].length>e,this}const fromJsonCell=e=>{if(null===e)return null;switch(e.type){case PieceType.PAWN:return Pawn.fromJson(e);case PieceType.KNIGHT:return Knight.fromJson(e);case PieceType.ROOK:return Rook.fromJson(e);case PieceType.KING:return King.fromJson(e);default:throw Error(`Unknown piece type: ${e.type}`)}};Board.fromJson=({squares:e,enPassant:t,promotion:i,gameStatus:n})=>new Board({squares:e.map(e=>e.map(e=>fromJsonCell(e))),enPassant:fromJsonCell(t),promotion:fromJsonCell(i),gameStatus:n});const DISABLED=!1;class PreconditionFailedError extends Error{constructor(e){super(e)}}const NULL_OR_UNDEFINED_MSG="Invalid argument value, null or undefined.";function checkNotNullOrUndefined(e,t=NULL_OR_UNDEFINED_MSG){if(utils.isNullOrUndefined(e))throw new PreconditionFailedError(t);return!0}function checkArgument(e=(()=>!0),t=""){if(!e())throw new PreconditionFailedError(t);return!0}function Cache(e=1e4){const t=Math.ceil(e/4);utils.debug("New cache with max entries:",e,"and max gen size",t);let i=new Map,n=new Map,s=new Map,o=new Map;this.clear=()=>{i=new Map,n=new Map,s=new Map,o=new Map},this.totalSize=()=>i.size+n.size+s.size+o.size;const r=(e,r)=>{utils.debug("Cache: addToGen1","key",e,"value",r),i.size>=t&&(utils.debug("Cache: updating generations. Gen size: ",i.size),o=s,s=n,n=i,i=new Map),i.set(e,r)};this.set=(e,t)=>{r(e,t),setTimeout(()=>n.delete(e)||s.delete(e)||o.delete(e),1)},this.get=e=>{const a=i.get(e);if(void 0!==a)return utils.debug("Cache: Found key",e,"in gen1, value",a),a;const c=n.get(e);if(void 0!==c)return utils.debug("Cache: Found key",e,"in gen2, value",c),setTimeout(()=>{n.delete(e),r(e,c)}),c;const l=s.get(e);if(void 0!==l)return utils.debug("Cache: Found key",e,"in gen3, value",l),setTimeout(()=>{s.delete(e),((e,i)=>{n.size>=t&&(o=s,s=n,n=new Map),n.set(e,i)})(e,l)},1),l;const u=o.get(e);return void 0!==u?(utils.debug("Cache: Found key",e,"in gen4, value",u),setTimeout(()=>{o.delete(e),((e,i)=>{s.size>=t&&(o=s,s=new Map),s.set(e,i)})(e,u)},1),u):(utils.debug("Cache: No value found for key",e),null)}}class BoardEvaluationError extends Error{constructor(e){super(e)}}let PIECE_SCORES={},PIECE_MOVES={};const PAWN_MOVES=[[0,1],[0,2],[-1,1],[1,1]],KNIGHT_MOVES=[[0,1],[0,-1],[1,-1],[1,0],[1,1],[-1,-1],[-1,0],[-1,1],[0,2],[0,-2],[2,-2],[2,0],[2,2],[-2,-2],[-2,0],[-2,2]],ROOK_MOVES=[[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,-1],[0,-2],[0,-3],[0,-4],[0,-5],[0,-6],[0,-7],[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],[7,0],[-1,0],[-2,0],[-3,0],[-4,0],[-5,0],[-6,0],[-7,0]],KING_MOVES=[[0,1],[0,-1],[1,-1],[1,0],[1,1],[-1,-1],[-1,0],[-1,1],[-2,0],[2,0]],initialize=()=>{PIECE_SCORES[PieceType.PAWN]=1,PIECE_SCORES[PieceType.KNIGHT]=2.5,PIECE_SCORES[PieceType.ROOK]=5,PIECE_SCORES[PieceType.KING]=184,PIECE_MOVES[PieceType.PAWN]=PAWN_MOVES,PIECE_MOVES[PieceType.KNIGHT]=KNIGHT_MOVES,PIECE_MOVES[PieceType.ROOK]=ROOK_MOVES,PIECE_MOVES[PieceType.KING]=KING_MOVES},roundToMillis=e=>Math.trunc(1e3*e)/1e3,getRookMultiplierForXY=e=>{checkNotNullOrUndefined(e);const{x:t,y:i}=e;let n=0,s=0;return 2===t?n+=.25:1!==t&&3!==t||(n+=.1),e.side===Side.WHITE?0===i?s+=.25:1===i&&(s+=.5):7===i?s+=.25:6===i&&(s+=.5),n+s},getRookMovementMultiplier=(e,t)=>{checkNotNullOrUndefined(e),checkNotNullOrUndefined(t);const i=genActionsForPiece(e,t);return(i.length+i.filter(e=>e.type===MoveType.ATTACK).map(({dst:e})=>e).map(([i,n])=>{const s=e.getPieceAt(i,n);return s.type===PieceType.KING?4:s.type===PieceType.ROOK&&s.power<t.power?2*(t.power-s.power):s.type===PieceType.KNIGHT&&s.power<t.power?t.power-s.power:0}).reduce((e,t)=>e+t,0)/20)/2},getRookPositionMultiplier=(e,t)=>{checkNotNullOrUndefined(e),checkNotNullOrUndefined(t);const i=getRookMultiplierForXY(t);return getRookMovementMultiplier(e,t)+i},getKnightMovementMultiplier=(e,t)=>{checkNotNullOrUndefined(e),checkNotNullOrUndefined(t);const i=genActionsForPiece(e,t);return(i.length+i.filter(e=>e.type===MoveType.ATTACK).map(({dst:e})=>e).map(([i,n])=>{const s=e.getPieceAt(i,n);return s.type===PieceType.ROOK?2+3*Math.max(0,t.power-s.power):s.type===PieceType.KING?4:s.type===PieceType.KNIGHT&&s.power<t.power?2*(t.power-s.power):s.type===PieceType.PAWN&&s.power<t.power?t.power-s.power:0}).reduce((e,t)=>e+t,0))/20/2},getKnightXYMultiplier=(e,t)=>{checkNotNullOrUndefined(e),checkNotNullOrUndefined(t);const{x:i,y:n}=t;let s=0,o=0;return 2===i?s+=.25:1!==i&&3!==i||(s+=.1),t.side===Side.WHITE?0===n?o+=.1:1===n||3===n?o+=.33:2===n&&(o+=.5):7===n?o+=.1:6===n||4===n?o+=.33:5===n&&(o+=.5),s+o},getKnightPositionMultiplier=(e,t)=>(checkNotNullOrUndefined(e),checkNotNullOrUndefined(t),getKnightXYMultiplier(e,t)+getKnightMovementMultiplier(e,t)),getPawnPositionMultiplier=(e,t)=>{checkNotNullOrUndefined(e),checkNotNullOrUndefined(t);const{x:i,y:n}=t;let s=0,o=0;return 2===i?s+=.25:1!==i&&3!==i||(s+=.1),t.side===Side.WHITE?5===n?o+=.1:4===n?o+=.2:3===n?o+=.25:2===n?o+=.33:1===n&&(o+=.5):2===n?o+=.1:3===n?o+=.2:4===n?o+=.25:5===n?o+=.33:6===n&&(o+=.5),s+o},getMultiplierForPiece=(e,t)=>{checkNotNullOrUndefined(e),checkNotNullOrUndefined(t);let i=0;switch(t.type){case PieceType.KNIGHT:i=getKnightPositionMultiplier(e,t);break;case PieceType.ROOK:i=getRookPositionMultiplier(e,t);break;case PieceType.PAWN:i=getPawnPositionMultiplier(e,t)}return roundToMillis(1+computeWinOdds(t.power,0)+i)},getValueForPiece=(e,t,i)=>{if(checkNotNullOrUndefined(e),checkNotNullOrUndefined(t),checkNotNullOrUndefined(i),utils.isNullOrUndefined(i))return 0;const n=PIECE_SCORES[i.type]*getMultiplierForPiece(e,i);return i.side===t?n:-n},gameEndedValue=(e,t)=>{checkNotNullOrUndefined(e),checkNotNullOrUndefined(t);const i=PIECE_SCORES[PieceType.KING];if(e===GameStatus.WHITE_WON)return t===Side.WHITE?i:-i;if(e===GameStatus.BLACK_WON)return t===Side.BLACK?i:-i;throw new BoardEvaluationError(`Invalid terminal game status: ${e}`)},genActionsForPiece=(e,t)=>{const{x:i,y:n}=t;return PIECE_MOVES[t.type].map(([e,i])=>[e,t.side===Side.WHITE?-i:i]).map(([e,t])=>[i+e,n+t]).map(([s,o])=>({src:[i,n],dst:[s,o],type:t.computeMoveType(e,s,o)})).filter(e=>e.type!==MoveType.INVALID)},genActions=(e,t)=>e.getRows().flat(2).filter(e=>null!==e).filter(e=>e.side===t).map(t=>genActionsForPiece(e,t)).flat(1),evaluate=(e,t)=>{if(checkNotNullOrUndefined(e),checkNotNullOrUndefined(t),e.gameStatus!==GameStatus.IN_PROGRESS)return gameEndedValue(e.gameStatus,t);const i=e.getRows().flat(2).filter(utils.isNotNullOrUndefined).map(i=>getValueForPiece(e,t,i)).reduce((e,t)=>e+t,0);return roundToMillis(i)};PIECE_SCORES[PieceType.PAWN]=1,PIECE_SCORES[PieceType.KNIGHT]=2.5,PIECE_SCORES[PieceType.ROOK]=5,PIECE_SCORES[PieceType.KING]=184,PIECE_MOVES[PieceType.PAWN]=PAWN_MOVES,PIECE_MOVES[PieceType.KNIGHT]=KNIGHT_MOVES,PIECE_MOVES[PieceType.ROOK]=ROOK_MOVES,PIECE_MOVES[PieceType.KING]=KING_MOVES;const PIECE_TYPE_HASH={},SIDE_HASH={};function initialize$1(){PIECE_TYPE_HASH[PieceType.PAWN]=0,PIECE_TYPE_HASH[PieceType.KNIGHT]=1,PIECE_TYPE_HASH[PieceType.ROOK]=2,PIECE_TYPE_HASH[PieceType.KING]=3,SIDE_HASH[Side.WHITE]=0,SIDE_HASH[Side.BLACK]=1}initialize$1();const pieceHash=e=>{if(null===e)return 64;const t=PIECE_TYPE_HASH[e.type],i=SIDE_HASH[e.side]<<2;let n=Math.min(Math.abs(e.power),3);return e.power<0&&(n&=4),n<<=3,t|i|n},computeRowHash=e=>e.map(e=>pieceHash(e)).map((e,t)=>e<<6*t).reduce((e,t)=>e|t),computeBoardHash=e=>e.getRows().map(e=>computeRowHash(e)).map(e=>BigInt(e)).map((e,t)=>e<<BigInt(30)*BigInt(t)).reduce((e,t)=>e|t),shuffleArray=e=>{for(let t=e.length-1;t>0;t--){const i=Math.floor(Math.random()*t),n=e[t];e[t]=e[i],e[i]=n}};function Engine({maxDepth:e=3,playingSide:t=null,timeLimitMillis:i=3e4}){checkArgument(()=>e>=0,"Depth can't be less than 0"),checkArgument(()=>t===Side.WHITE||t===Side.BLACK,"Side needs to be Side.WHITE or Side.BLACK");const n=new Cache(2e4),s=new Cache(2e4);this.whiteCache=n,this.blackCache=s,this.cacheHits=0;let o=0,r=0;this.lastDuration=()=>r-o;const a=(e,t)=>{const{src:i,dst:n,type:s}=t;switch(s){case MoveType.MOVE:case MoveType.CASTLE:return[{boards:[e.makeMove(i,n)],odds:1}];case MoveType.ATTACK:{const t=computePieceWinOdds(e.getPieceAt(...i),e.getPieceAt(...n));return[{boards:[e.makeMove(i,n,EngineOutcome.ALWAYS_WIN)],odds:t},{boards:[e.makeMove(i,n,EngineOutcome.ALWAYS_LOSE)],odds:1-t}]}case MoveType.EN_PASSANT_ATTACK:{const[t,s]=i,[o,r]=n;const a=computePieceWinOdds(e.getPieceAt(t,s),e.getPieceAt(o,s));return[{boards:[e.makeMove(i,n,EngineOutcome.ALWAYS_WIN)],odds:a},{boards:[e.makeMove(i,n,EngineOutcome.ALWAYS_LOSE)],odds:1-a}]}case MoveType.PROMOTION_ATTACK:const t=computePieceWinOdds(e.getPieceAt(...i),e.getPieceAt(...n)),o=e.makeMove(i,n,EngineOutcome.ALWAYS_WIN);return[{boards:[e.makeMove(i,n,EngineOutcome.ALWAYS_LOSE)],odds:1-t},{boards:[o.setPromotion(PieceType.ROOK),o.setPromotion(PieceType.KNIGHT)],odds:t}];case MoveType.SACRIFICE:return[{boards:[e.makeMove(i,n)],odds:1}];case MoveType.PROMOTION:const r=e.makeMove(i,n);return[{boards:[r.setPromotion(PieceType.ROOK),r.setPromotion(PieceType.KNIGHT)],odds:1}];default:throw new Error(`Invalid move type: ${s}`)}},c=(e,i,n,s,o)=>{checkNotNullOrUndefined(e),checkNotNullOrUndefined(i),checkNotNullOrUndefined(n);const r=t===i.curSide,a=!r;return e.map(e=>u(e,i,n,s,o)).reduce((e,t)=>r&&e.score>=t.score||a&&e.score<=t.score?e:t)};this.computeMove=(n,s={alpha:-1e3,beta:1e3,curSide:t},r=0)=>{let a=0;0==r&&(this.cacheHits=0,o=new Date,a=o+i);const c=(t=>{const i=t.getRows().flat(2).filter(e=>null!==e).length;return i<=15&&i>10?Math.round(1.1*e):i<=10&&i>5?Math.round(1.2*e):i<=5?Math.round(1.3*e):e})(n);return u(n,s,r,c,a)};const l=()=>new Date,u=(e,n,s,u,T)=>{if(e.gameStatus!==GameStatus.IN_PROGRESS||s>u||l()>=T||l()-o>=i)return{score:evaluate(e,t),action:null,depth:s};let{alpha:h=-1e3,beta:A=1e3,curSide:E=t}=n;const P=computeBoardHash(e),O=d(P,E);if(null!=O&&O.depth<=s)return this.cacheHits++,O;const y=E===t,g=!y,N=genActions(e,E);shuffleArray(N);let I=y?-1e3:1e3,S=null;for(let t=0;t<N.length;t++){const{src:i,dst:n}=N[t],o=a(e,N[t]),r={alpha:h,beta:A,curSide:(m=E,m===Side.WHITE?Side.BLACK:Side.WHITE)};let d=T;0===s&&(d=l()+T/N.length);const p=o.map(({boards:e,odds:t})=>{const{score:i}=c(e,r,s+1,u,d);return{odds:t,possibleScore:i}}).map(({possibleScore:e,odds:t})=>e*t).reduce((e,t)=>e+t);if(y&&I<p){if(I=p,S=N[t],h=Math.max(h,I),A<=h)break}else if(g&&I>p&&(I=p,S=N[t],A=Math.min(A,I),A<=h))break}var m;const M={score:I,action:S,depth:s};return p(P,E,M),0===s&&(r=new Date),M},d=(e,t)=>t===Side.WHITE?n.get(e):s.set(e),p=(e,t,i)=>{t===Side.WHITE?n.set(e,i):s.set(e,i)}}const logResults=(e,t)=>{utils.info("Result:",JSON.stringify(e)),utils.info("Time:",t.lastDuration()/1e3,"s"),utils.info("Cache hits:",t.cacheHits),utils.info("White cache size:",t.whiteCache.totalSize()),utils.info("Black cache size:",t.blackCache.totalSize())},engine=new Engine({maxDepth:4,playingSide:Side.BLACK});onmessage=({data:e})=>{const{board:t,side:i,engineMoveId:n}=e;new Promise((e,i)=>{utils.enableLogging(),utils.info("Computing my next move..."),utils.disableLogging(),setTimeout(()=>e(engine.computeMove(Board.fromJson(t))),1)}).then(e=>{e.action.engineMoveId=n,postMessage(e.action),utils.enableLogging(),logResults(e,engine),utils.disableLogging()})};